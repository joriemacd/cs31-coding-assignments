'''
helper function reading the n first numbers of pi and returns a list containing these,
the function was given on canvas
'''

def read_pi(n):
    #opens the file name "pi" and reads the first n digits
    #puts it in the list pi, and returns that list
    pi = list()
    f = open('pi','r')
    for i in range(n):
        d = f.read(1)
        pi.append(int(d))
    return pi
	
	
def square_pi_poly(n):
    # s is the sum of squares of the coefficients of the polynomial
    s = 0
    # read the first (n + 1) digits of pi
    P = read_pi(n)
    # TODO -- comment out
    # when we have karatsuba
    # call karatsuba's algorithm to get R, i.e.,
    # the square of the P(n) polynomial
    #R = karatsuba_multi_poly(P, P)
    R = [9,6,25,14,18,8,1]
    for i in range(0, len(R)):
        s = s + math.pow(R[i],2)
    
    return s
	
	
	print(square_pi_poly(3))
	# 1327 



############## NAIVE SOLUTION ######################
import math
import time

# input P, Q are the two lists of polynomial coefficients
# output R, i.e., the product of the two polynomials
# given that P and Q are of the same length of [1:n], they must have the same order as well

def multi_poly(P, Q):
    # R contains the coefficients of the product polynomial
    R = []; n = len(P) - 1; val = 0; time_val = time.time()
    # TODO -- base cases
    # for k <= 2n
    for k in range(0, 2 * n + 1):
        if (k <= n):
            val = 0
            # for i <= k
            for i in range(0, k + 1):
                val = val + (P[i] * Q[k-i])
        else:
            val = 0
            for i in range(k - n, n + 1):
                val = val + (P[i] * Q[k - i])
        R.append(val)
        run_time = time.time() - time_val
    return (R, run_time)



################### 1d i )

'''
Create loop that goes iterates through numbers a 0 to 10000 with step of 100, 
Calculates time to run both algorithms for a numbers of pi, and stores each runtime 
in pandas dataframe
''' 

import pandas as pd
# name columns
cols = ['naive', 'karatsuba']
# create dataframe
df = pd.DataFrame(columns=cols, index=range(0, 10001, 100))
# loop through each value
for a in range(0, 10001, 100):
    # add time to run for naive algorithm
    df.loc[a].naive = multi_poly(read_pi(a))[2]
    # add time to run for 'fast' algorithm
    df.loc[a].karatsuba = karatsuba_multi_poly(read_pi(a))[2]

### NEED TO DROP TOP COLUMN AND REPLACE WITH 1 INDEX AND VALUES?
_______________-
#plot the data against itself 
df.plot(title = 'Number \'n\' vs. Time Taken to Implement', xlabel= 'Number \'n\'', ylabel= 'Time (s)')
